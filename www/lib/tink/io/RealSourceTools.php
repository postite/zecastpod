<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ 3018ab1)
 */

namespace tink\io;

use \tink\core\_Promise\Promise_Impl_;
use \tink\streams\_Stream\Stream_Impl_;
use \tink\core\Outcome;
use \tink\chunk\ChunkObject;
use \php\Boot;
use \tink\core\TypedError;
use \tink\core\_Future\FutureObject;
use \tink\core\MPair;
use \tink\core\_Promise\Next_Impl_;
use \tink\streams\StreamObject;
use \tink\io\_Source\Source_Impl_;
use \tink\streams\Single;
use \php\_Boot\HxAnon;
use \tink\core\_Lazy\LazyConst;
use \tink\io\_StreamParser\StreamParser_Impl_;

class RealSourceTools {
	/**
	 * @param StreamObject $s
	 * 
	 * @return FutureObject
	 */
	static public function all ($s) {
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:156: lines 156-159
		return Source_Impl_::concatAll($s)->map(function ($o) {
			#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:156: lines 156-159
			switch ($o->index) {
				case 1:
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:158: characters 23-33
					return Outcome::Failure($o->params[0]);
					break;
				case 2:
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:157: characters 24-34
					return Outcome::Success($o->params[0]);
					break;
			}
		})->gather();
	}


	/**
	 * @param StreamObject $s
	 * @param \Closure $rescue
	 * 
	 * @return StreamObject
	 */
	static public function idealize ($s, $rescue) {
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:187: characters 5-69
		return Source_Impl_::chunked($s)->idealize($rescue);
	}


	/**
	 * @param StreamObject $s
	 * @param StreamParserObject $p
	 * 
	 * @return FutureObject
	 */
	static public function parse ($s, $p) {
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:162: lines 162-165
		return StreamParser_Impl_::parse($s, $p)->map(function ($r) {
			#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:162: lines 162-165
			switch ($r->index) {
				case 0:
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:163: characters 32-61
					return Outcome::Success(new MPair($r->params[0], $r->params[1]));
					break;
				case 1:
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:164: characters 38-48
					return Outcome::Failure($r->params[0]);
					break;
				case 2:
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:164: characters 38-48
					return Outcome::Failure($r->params[0]);
					break;
			}
		})->gather();
	}


	/**
	 * @param StreamObject $s
	 * @param StreamParserObject $p
	 * 
	 * @return StreamObject
	 */
	static public function parseStream ($s, $p) {
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:184: characters 5-42
		return StreamParser_Impl_::parseStream($s, $p);
	}


	/**
	 * @param StreamObject $src
	 * @param ChunkObject $delim
	 * 
	 * @return object
	 */
	static public function split ($src, $delim) {
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:168: characters 5-45
		$s = RealSourceTools::parse($src, new Splitter($delim));
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:171: lines 171-174
		$tmp = Stream_Impl_::promise(Promise_Impl_::ofSpecific(Promise_Impl_::next($s, Next_Impl_::ofSafeSync(function ($p)  use (&$src) {
			#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:171: characters 116-119
			$_g = $p->a;
			#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:171: characters 116-119
			switch ($_g->index) {
				case 0:
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:172: characters 27-45
					return new Single(new LazyConst($_g->params[0]));
					break;
				case 1:
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:173: characters 20-23
					return $src;
					break;
			}
		}))));
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:175: lines 175-178
		$tmp1 = Promise_Impl_::next($s, function ($p1)  use (&$delim) {
			#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:175: characters 51-54
			switch ($p1->a->index) {
				case 0:
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:176: characters 9-28
					return Promise_Impl_::ofOutcome(Outcome::Success($delim));
					break;
				case 1:
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:177: characters 9-62
					return Promise_Impl_::ofOutcome(Outcome::Failure(new TypedError(404, "Delimiter not found", new HxAnon([
						"fileName" => "tink/io/Source.hx",
						"lineNumber" => 177,
						"className" => "tink.io.RealSourceTools",
						"methodName" => "split",
					]))));
					break;
			}
		});
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:170: lines 170-180
		return new HxAnon([
			"before" => $tmp,
			"delimiter" => $tmp1,
			"after" => Stream_Impl_::promise(Promise_Impl_::ofSpecific(Promise_Impl_::next($s, Next_Impl_::ofSafeSync(function ($p2) {
				#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx:179: characters 101-111
				return $p2->b;
			})))),
		]);
	}
}


Boot::registerClass(RealSourceTools::class, 'tink.io.RealSourceTools');
