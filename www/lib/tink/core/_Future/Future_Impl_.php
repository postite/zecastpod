<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ 3018ab1)
 */

namespace tink\core\_Future;

use \php\_Boot\HxClosure;
use \tink\core\FutureTrigger;
use \tink\core\OutcomeTools;
use \tink\core\Outcome;
use \php\Boot;
use \tink\core\_Outcome\OutcomeMapper_Impl_;
use \tink\core\MPair;
use \tink\core\_Callback\Callback_Impl_;
use \tink\core\Noise;
use \tink\core\_Lazy\LazyObject;
use \haxe\ds\Either;
use \tink\core\_Lazy\LazyConst;

final class Future_Impl_ {
	/**
	 * @var FutureObject
	 */
	static public $NEVER;
	/**
	 * @var FutureObject
	 */
	static public $NOISE;
	/**
	 * @var FutureObject
	 */
	static public $NULL;


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _flatMap ($f, $map) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:177: characters 12-26
		return $f->flatMap($map)->gather();
	}


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _map ($f, $map) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:180: characters 12-22
		return $f->map($map)->gather();
	}


	/**
	 * @param \Closure $f
	 * 
	 * @return FutureObject
	 */
	static public function _new ($f) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:12: character 17
		return new SimpleFuture($f);
	}


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _tryFailingFlatMap ($f, $map) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:159: lines 159-162
		return $f->flatMap(function ($o)  use (&$map) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:159: lines 159-162
			switch ($o->index) {
				case 0:
					#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:160: characters 24-30
					return $map($o->params[0]);
					break;
				case 1:
					#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:161: characters 24-47
					return new SyncFuture(new LazyConst(Outcome::Failure($o->params[0])));
					break;
			}
		})->gather();
	}


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _tryFailingMap ($f, $map) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:171: characters 12-53
		return $f->map(function ($o)  use (&$map) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:171: characters 31-52
			return OutcomeTools::flatMap($o, OutcomeMapper_Impl_::withSameError($map));
		})->gather();
	}


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _tryFlatMap ($f, $map) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:165: lines 165-168
		return $f->flatMap(function ($o)  use (&$map) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:165: lines 165-168
			switch ($o->index) {
				case 0:
					#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:166: characters 24-43
					return $map($o->params[0])->map(new HxClosure(Outcome::class, 'Success'))->gather();
					break;
				case 1:
					#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:167: characters 24-47
					return new SyncFuture(new LazyConst(Outcome::Failure($o->params[0])));
					break;
			}
		})->gather();
	}


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _tryMap ($f, $map) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:174: characters 12-49
		return $f->map(function ($o)  use (&$map) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:174: characters 31-48
			return OutcomeTools::map($o, $map);
		})->gather();
	}


	/**
	 *  Uses `Pair` to merge two futures
	 * 
	 * @param FutureObject $a
	 * @param FutureObject $b
	 * 
	 * @return FutureObject
	 */
	static public function and ($a, $b) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:156: characters 5-61
		return Future_Impl_::merge($a, $b, function ($a1, $b1) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:156: characters 46-60
			return new MPair($a1, $b1);
		});
	}


	/**
	 *  Casts a Surprise into a Promise
	 * 
	 * @param FutureObject $s
	 * 
	 * @return FutureObject
	 */
	static public function asPromise ($s) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:88: characters 5-13
		return $s;
	}


	/**
	 *  Creates an async future
	 *  Example: `var i = Future.async(function(cb) cb(1)); // Future<Int>`
	 * 
	 * @param \Closure $f
	 * @param bool $lazy
	 * 
	 * @return FutureObject
	 */
	static public function async ($f, $lazy = false) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:131: lines 131-138
		if ($lazy === null) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:131: lines 131-138
			$lazy = false;
		}
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:131: lines 131-138
		if ($lazy) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:132: characters 7-32
			return new LazyTrigger($f);
		} else {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:134: characters 7-26
			$op = new FutureTrigger();
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:136: characters 7-33
			Callback_Impl_::invoke($f, new HxClosure($op, 'trigger'));
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:137: characters 7-16
			return $op;
		}
	}


	/**
	 *  Same as `first`, but use `Either` to handle the two different types
	 * 
	 * @param FutureObject $a
	 * @param FutureObject $b
	 * 
	 * @return FutureObject
	 */
	static public function either ($a, $b) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:150: characters 5-71
		return Future_Impl_::first($a->map(new HxClosure(Either::class, 'Left')), $b->map(new HxClosure(Either::class, 'Right')));
	}


	/**
	 *  Creates a future that contains the first result from `this` or `other`
	 * 
	 * @param FutureObject $this
	 * @param FutureObject $other
	 * 
	 * @return FutureObject
	 */
	static public function first ($this1, $other) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:19: characters 5-32
		$ret = new FutureTrigger();
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:20: characters 5-39
		$l1 = $this1->handle(new HxClosure($ret, 'trigger'));
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:21: characters 5-40
		$l2 = $other->handle(new HxClosure($ret, 'trigger'));
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:22: characters 5-30
		$ret1 = $ret;
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:23: lines 23-24
		if ($l1 !== null) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:24: characters 18-20
			$this2 = $l1;
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:24: characters 7-21
			$ret1->handle(function ($_)  use (&$this2) {
				#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:24: characters 18-20
				$this2->cancel();
			});
		}
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:25: lines 25-26
		if ($l2 !== null) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:26: characters 18-20
			$this3 = $l2;
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:26: characters 7-21
			$ret1->handle(function ($_1)  use (&$this3) {
				#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:26: characters 18-20
				$this3->cancel();
			});
		}
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:27: characters 5-15
		return $ret1;
	}


	/**
	 *  Creates a new future by applying a transform function to the result.
	 *  Different from `map`, the transform function of `flatMap` returns a `Future`
	 * 
	 * @param FutureObject $this
	 * @param \Closure $next
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	static public function flatMap ($this1, $next, $gather = true) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:45: lines 45-50
		if ($gather === null) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:45: lines 45-50
			$gather = true;
		}
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:46: characters 5-34
		$ret = $this1->flatMap($next);
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:48: lines 48-49
		if ($gather) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:48: characters 19-31
			return $ret->gather();
		} else {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:49: characters 12-15
			return $ret;
		}
	}


	/**
	 *  Flattens `Future<Future<A>>` into `Future<A>`
	 * 
	 * @param FutureObject $f
	 * 
	 * @return FutureObject
	 */
	static public function flatten ($f) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:71: characters 5-31
		return new NestedFuture($f);
	}


	/**
	 * @param \Array_hx $futures
	 * 
	 * @return FutureObject
	 */
	static public function fromMany ($futures) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:112: characters 5-27
		return Future_Impl_::ofMany($futures);
	}


	/**
	 * @param LazyObject $l
	 * 
	 * @return FutureObject
	 */
	static public function lazy ($l) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:116: characters 5-29
		return new SyncFuture($l);
	}


	/**
	 *  Creates a new future by applying a transform function to the result.
	 *  Different from `flatMap`, the transform function of `map` returns a sync value
	 * 
	 * @param FutureObject $this
	 * @param \Closure $f
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	static public function map ($this1, $f, $gather = true) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:34: lines 34-39
		if ($gather === null) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:34: lines 34-39
			$gather = true;
		}
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:35: characters 5-27
		$ret = $this1->map($f);
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:37: lines 37-38
		if ($gather) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:37: characters 19-31
			return $ret->gather();
		} else {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:38: characters 12-15
			return $ret;
		}
	}


	/**
	 *  Merges two futures into one by applying the merger function on the two future values
	 * 
	 * @param FutureObject $this
	 * @param FutureObject $other
	 * @param \Closure $merger
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	static public function merge ($this1, $other, $merger, $gather = true) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:63: lines 63-65
		if ($gather === null) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:63: lines 63-65
			$gather = true;
		}
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:63: lines 63-65
		$ret = $this1->flatMap(function ($t)  use (&$other, &$merger) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:64: characters 14-66
			return $other->map(function ($a)  use (&$t, &$merger) {
				#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:64: characters 39-58
				return $merger($t, $a);
			});
		});
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:63: lines 63-65
		if ($gather) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:63: lines 63-65
			return $ret->gather();
		} else {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:63: lines 63-65
			return $ret;
		}
	}


	/**
	 *  Like `map` and `flatMap` but with a polymorphic transformer and return a `Promise`
	 *  @see `Next`
	 * 
	 * @param FutureObject $this
	 * @param \Closure $n
	 * 
	 * @return FutureObject
	 */
	static public function next ($this1, $n) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:57: characters 5-50
		return $this1->flatMap(function ($v)  use (&$n) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:57: characters 38-49
			return $n($v);
		});
	}


	/**
	 * @param mixed $v
	 * 
	 * @return FutureObject
	 */
	static public function ofAny ($v) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:82: characters 5-26
		return new SyncFuture(new LazyConst($v));
	}


	/**
	 *  Merges multiple futures into Future<Array<A>>
	 * 
	 * @param \Array_hx $futures
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	static public function ofMany ($futures, $gather = true) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:93: lines 93-108
		if ($gather === null) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:93: lines 93-108
			$gather = true;
		}
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:94: characters 5-24
		$ret = new SyncFuture(new LazyConst(new \Array_hx()));
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:95: lines 95-104
		$_g = 0;
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:95: lines 95-104
		while ($_g < $futures->length) {
			unset($f);
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:95: characters 10-11
			$f = ($futures->arr[$_g] ?? null);
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:95: lines 95-104
			$_g = $_g + 1;
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:96: lines 96-104
			$ret = $ret->flatMap(function ($results)  use (&$f) {
				#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:98: lines 98-102
				return $f->map(function ($result)  use (&$results) {
					#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:100: characters 15-46
					return $results->concat(\Array_hx::wrap([$result]));
				});
			});
		}

		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:106: lines 106-107
		if ($gather) {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:106: characters 19-31
			return $ret->gather();
		} else {
			#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:107: characters 12-15
			return $ret;
		}
	}


	/**
	 *  Same as `first`
	 * 
	 * @param FutureObject $a
	 * @param FutureObject $b
	 * 
	 * @return FutureObject
	 */
	static public function or ($a, $b) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:144: characters 5-22
		return Future_Impl_::first($a, $b);
	}


	/**
	 *  Creates a sync future.
	 *  Example: `var i = Future.sync(1); // Future<Int>`
	 * 
	 * @param mixed $v
	 * 
	 * @return FutureObject
	 */
	static public function sync ($v) {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:123: characters 5-29
		return new SyncFuture(new LazyConst($v));
	}


	/**
	 *  Creates a new `FutureTrigger`
	 * 
	 * @return FutureTrigger
	 */
	static public function trigger () {
		#/Users/ut/haxe/haxe_libraries/tink_core/1.18.0/haxelib/src/tink/core/Future.hx:186: characters 5-31
		return new FutureTrigger();
	}


	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


self::$NULL = new SyncFuture(new LazyConst(null));
self::$NOISE = new SyncFuture(new LazyConst(Noise::Noise()));
self::$NEVER = new SyncFuture(new LazyConst(NeverFuture::$inst));
	}
}


Boot::registerClass(Future_Impl_::class, 'tink.core._Future.Future_Impl_');
Future_Impl_::__hx__init();
