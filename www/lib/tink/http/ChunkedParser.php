<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ 3018ab1)
 */

namespace tink\http;

use \tink\core\Outcome;
use \php\Boot;
use \tink\core\TypedError;
use \tink\io\ParseStep;
use \haxe\io\_BytesData\Container as _BytesDataContainer;
use \haxe\io\Bytes;
use \tink\chunk\ChunkCursor;
use \tink\_Chunk\Chunk_Impl_;
use \tink\io\StreamParserObject;
use \tink\chunk\_Seekable\Seekable_Impl_;
use \php\_Boot\HxAnon;

class ChunkedParser implements StreamParserObject {
	/**
	 * @var \Array_hx
	 */
	static public $LINEBREAK;


	/**
	 * @var int
	 */
	public $chunkSize;


	/**
	 * @return void
	 */
	public function __construct () {
		#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:62: characters 3-10
		$this->reset();
	}


	/**
	 * @param ChunkCursor $rest
	 * 
	 * @return Outcome
	 */
	public function eof ($rest) {
		#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:89: characters 10-95
		if ($this->chunkSize === 0) {
			#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:89: characters 27-47
			return Outcome::Success(Chunk_Impl_::$EMPTY);
		} else {
			#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:89: characters 50-95
			return Outcome::Failure(new TypedError(null, "Unexpected end of input", new HxAnon([
				"fileName" => "tink/http/Chunked.hx",
				"lineNumber" => 89,
				"className" => "tink.http.ChunkedParser",
				"methodName" => "eof",
			])));
		}
	}


	/**
	 * @param ChunkCursor $cursor
	 * 
	 * @return ParseStep
	 */
	public function progress ($cursor) {
		#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:70: lines 70-85
		if ($this->chunkSize < 0) {
			#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:71: characters 12-34
			$_g = $cursor->seek(ChunkedParser::$LINEBREAK);
			#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:71: characters 12-34
			switch ($_g->index) {
				case 0:
					#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:72: characters 20-52
					$this->chunkSize = \Std::parseInt("0x" . ($_g->params[0]->toString()??'null'));
					break;
				case 1:
										break;
			}

			#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:75: characters 5-15
			return ParseStep::Progressed();
		} else if ($this->chunkSize === 0) {
			#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:77: characters 5-15
			return ParseStep::Progressed();
		} else if ($cursor->length >= ($this->chunkSize + 2)) {
			#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:80: characters 13-35
			$_g1 = $cursor->seek(ChunkedParser::$LINEBREAK);
			#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:80: characters 13-35
			switch ($_g1->index) {
				case 0:
					#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:81: characters 21-28
					$this->reset();
					#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:81: characters 30-37
					return ParseStep::Done($_g1->params[0]);
					break;
				case 1:
					#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:82: characters 18-55
					return ParseStep::Failed(new TypedError(null, "Invalid encoding", new HxAnon([
						"fileName" => "tink/http/Chunked.hx",
						"lineNumber" => 82,
						"className" => "tink.http.ChunkedParser",
						"methodName" => "progress",
					])));
					break;
			}
		} else {
			#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:84: characters 10-20
			return ParseStep::Progressed();
		}
	}


	/**
	 * @return void
	 */
	public function reset () {
		#/Users/ut/haxe/haxe_libraries/tink_http/0.8.2/github/403eb075dff5d7b8ec4a9e08052eb01e1e196722/src/tink/http/Chunked.hx:66: characters 3-17
		$this->chunkSize = -1;
	}


	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


self::$LINEBREAK = Seekable_Impl_::ofBytes(new Bytes(strlen("\x0D\x0A"), new _BytesDataContainer("\x0D\x0A")));
	}
}


Boot::registerClass(ChunkedParser::class, 'tink.http.ChunkedParser');
ChunkedParser::__hx__init();
